// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "@openzeppelin/contracts/utils/math/Math.sol";
import "./Trigonometry.sol";
import "./SVG.sol";

import "../struct/RoseCurve.sol";

/**
 * @title RoseCurveSVG library providing useful functions to create Rose Curve SVGs
 * @author leovct
 */
library RoseCurveSVG {
    /**
     * @notice Create a Rose Curve SVG
     * @param _roseCurve    the rose curve struct
     * @param _randomNumber a random number used to generated random colours
     * @return shape        the rose curve svg
     */
    function _createRoseCurveSVG(RoseCurve memory _roseCurve, uint256 _randomNumber)
        internal pure returns (string memory) {
        string memory background = SVG._createRect(
            -int256(_roseCurve.size),
            -int256(_roseCurve.size),
            2 * _roseCurve.size,
            2 * _roseCurve.size,
            _roseCurve.backgroundColour
        );

        string memory firstPattern = SVG._createShape(string(abi.encodePacked(
            _createPattern(7, 8, _roseCurve, _randomNumber),
            SVG._createRotationAnimation(false, _roseCurve.rotationPeriod)
        )));

        string memory secondPattern = SVG._createShape(string(abi.encodePacked(
            _createPattern(4, 5, _roseCurve, _randomNumber),
            SVG._createRotationAnimation(false, _roseCurve.rotationPeriod)
        )));

        return SVG._createSVG(_roseCurve.size, _roseCurve.size,
            string(abi.encodePacked(background, firstPattern, secondPattern)));
    }

    /**
     * @notice Create a Rose Curve SVG pattern
     * @dev A rose curve is a set of polar coordinates specified by r = a*cos(k*theta) with k = n/d
     * @param _n            the n parameter of the rose curve equation
     * @param _d            the n parameter of the rose curve equation
     * @param _roseCurve    the rose curve struct
     * @param _randomNumber a random number used to generate random colours
     * @return shape        the rose curve svg pattern
     */
    function _createPattern(uint256 _n, uint256 _d, RoseCurve memory _roseCurve, uint256 _randomNumber) 
        internal pure returns (string memory shape) {
        string memory pointColour = _roseCurve.paletteColours[_randomNumber % 5];

        int256 a = int256(_roseCurve.size) - 20;
        uint256 k = _n / _d;

        uint256 numberPointsWithSameColour = 0;
        uint256 theta = 0;
        while (theta < 2 * Trigonometry.TWO_PI * _d) {
            // Compute the polar coordinates of the point
            int256 r = a * Trigonometry.cos(k * theta);

            // Compute the cartesian coordinates of the point
            int256 x = r * Trigonometry.cos(theta);
            int256 y = r * Trigonometry.sin(theta);

            // Create the svg shape of the point
            shape = string(abi.encodePacked(shape, SVG._createCircle(x, y, _roseCurve.pointRadius, pointColour)));

            // Increment values
            numberPointsWithSameColour++;
            theta += _roseCurve.step;

            // Update the colour of the point if needed
            if (numberPointsWithSameColour >= _roseCurve.colourLineLength) {
                uint256 newRandomNumber = _generateNewRandom(_randomNumber, theta);
                pointColour = _roseCurve.paletteColours[newRandomNumber % 5];
            }
        }
    }

    /**
     * @notice Generate a new random number
     * @param _oldRandomNumber the old random number generated by Chainlink VRF
     * @param _n another number
     * @return a new random number
     */
    function _generateNewRandom(uint256 _oldRandomNumber, uint256 _n) internal pure returns (uint256) {
        return uint256(keccak256(abi.encode(_oldRandomNumber, _n)));
    }
}
